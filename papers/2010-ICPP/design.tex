\section{Design}
\label{section:design}

In this section we describe the design of our classes and algorithms based on
the requirements established in \ref{section:requirements}.

\subsection{How to Run the Subsetter}

The success of the NetCDF Operators and similar tools demonstrate the need for
user-ready applications for the analysis of their data while the success of
tools such as CDAT validate the need for a scriptable interface and customization of
basic and advanced operators.  We plan to provide both the scriptable
interface as well as a set of predefined tools.

The subsetter is the first in a series of planned parallel command-line tools
based on unstructured grids and the PGAS programming model.  It takes
arguments specifying specific variables (-v) or dimension ranges (-d) to
extract, or at a higher level a latitude and longitude bounding box (-b).  In
this way it is most akin to the NetCDF Operators' "kitchen sink" application.
Example usage looks like: \begin{itemize} \item mpiexec -np 128 subsetter -b
20,-20,160,90 -v vorticity january.nc february.nc MJO\_vorticity\_janfeb.nc
\item mpiexec -np 64 subsetter -b 90,0,180,-180 -d levels,1,5 geopotential.nc
\end{itemize}

\subsection{Dataset Abstraction}

The subsetter minimally supports two forms of input file aggregation, either
across a specified dimension e.g. time or by taking the union of all input
files such that duplicate dimensions and variables within later files are
ignored.  These forms of aggregation are modeled after what is available when
using NetCDF Markup Language.\cite{NcML} NcML input is not directly supported
at this time but is planned for a future release. 

TODO

\subsection{Parallel IO Abstraction}

The use of Parallel NetCDF was selected because of the ubiquity of the NetCDF
libraries and data format in climate applications.

\subsection{The Global Arrays Library}

The partitioned global address space (PGAS) programming model assumes a global
address space which is partitioned such that each process is associated with a
local portion of the space.  One-sided communication allows a process to
access another process's address space without any explicit participation by
the latter process.  Such communication can reduce synchronization, reduce
data movement, and can simplify programming.  The Global Arrays (GA) library
supports both models.

The subsetter was built using the GA library for the wealth of features it
provides which are tailored to our problem domain.  GA provides a distributed
dense multidimensional array programming abstraction and the data we will be
operating over is stored as dense arrays within NetCDF files.  It should be
noted that dense distributed arrays would also work well for regularly gridded
data.  However, due to the use of unstructured grid data, the algorithm for
subsetting the data will look quite different than for the structured case.
Recall that for unstructured grids, logically adjacent cells are not
necessarily adjacent in memory.  In order to evenly distribute a subset, a
single process will need to send a varying amount of data to any number of
other processes.  Certainly a collective operation could be considered, but GA
provides the necessary functionality without needing any explicit cooperation
from any other process.  Any given process will simply put the section of the
subset into the remote process's memory.

There are certain GA one-sided operations which are tailored for use on
one-dimensional arrays which are prevalent within our data.  These operations
include \verb=GA_Patch_enum=, \verb=GA_Scan_add=, \verb=GA_Scan_copy=,
\verb=GA_Pack=, and \verb=GA_Unpack=.  Those operations have been demonstrated
in the computation of sparse matrix multiplication\cite{GA} but are equally
useful in the manipulation of unstructured grids.  The remaining GA operations
are N-dimensional and include \verb=NGA_Scatter=, \verb=NGA_Gather=,
\verb=GA_Put=.  Those operations are useful for redistributing the subset
data.

\subsection{The Algorithms}

The one-sided communications and PGAS model supported by GA allowed us to
develop some novel algorithms for the manipulation of unstructured grids.  In
this section we diagram and describe the algorithms we developed.  The vast
majority of functionality within the subsetter is provided by either PnetCDF
or GA.  GA allocates and evenly distributes the arrays which are then filled
with data by PnetCDF.  GA operations are then used to prepare the data for
packing at which point a custom n-dimensional packing routine is used.  The
packed, evenly-distributed data is then written back to disk using PnetCDF.
Of these algorithms, the novel ones include reindexing the masks, reindexing
the connectivity variables, and the n-dimensional pack routine.

Each dimension of the data has two arrays associated with it, a bitmask and an
integer array representing the new indices of the dimension in case of a
subset.  For instance, if any of the bits are turned off, the corresponding
indices of the index array will have negative values.  The remaining values of
the index array will increase monotonically, skipping the negative or masked
indices.  The bitmasks are generated based on a rectangular latitude and
longitude region specified on the command-line, or by specifying one or more
indices of a dimension to select.  Although a rectangular region is currently
used for simplicity, once translated the bitmasks allow for arbitrary subsets
to be defined.  These bitmasks are then used to evenly distribute the
resultant subset across all processes.  Note that these bitmask and associated
index arrays are one-dimensional and distributed.

\subsubsection{Partial Sum}

\begin{figure}[!t]
\center
\includegraphics[width=3.5in]{images/partialsum}
\caption{Distributed partial sum on a 1-D array}
\label{fig:partialsum}
\end{figure}

A partial sum of the index array associated with each dimension is useful for
later determining where subset data is to be placed.  That feature will be
explained in more detail in \ref{section:alg_pack}.  The partial sum operation
here is semantically similar to the one found in the C++ STL\cite{CXXSTL}.  It
computes a series of sums over an array from the first element through the
\emph{i}th element and stores the result of each such sum in the \emph{i}th
element of a destination array.

The partial sum is computed by first performing partial sums of each local
portion of the source array.  This operation is the first line in
\ref{fig:partialsum}.  The last value of each local sum is then collectively
distributed to each process as seen in the second line of the figure.  As the
last step and list line in the figure, each local portion adds the last values
of each process's sum which come before.

\subsubsection{Reindexing of Dimension Index}

\begin{figure}[!t]
\center
\includegraphics[width=3.5in]{images/unpack}
\caption{Reindexing of a Dimension Index}
\label{fig:unpack}
\end{figure}

Creating the index array associated with a mask is the easiest of the
algorithms.  It only requires three specific GA operations, \verb=GA_Fill=,
\verb=GA_Patch_enum= and \verb=GA_Unpack=.  \verb=GA_Fill= fills the index
array with a value of $-1$.  \verb=GA_Patch_enum= enumerates the values of a
second array starting from zero with an increment of 1.  \verb=GA_Unpack=
expands the enumerated array values into the filled array based on the
associated mask array.

\subsubsection{REINDEXING OF CONNECTIVITY VARIABLES}

\begin{figure}[!t]
\center
\includegraphics[width=3.5in]{images/reindex}
\caption{Reindexing of Topology Variables}
\label{fig:reindex}
\end{figure}

Recall that the connectivity variables are those which map from one index to
one or more other indices such as from a cell index to each of its corner
indices.  A typical subset operation reduces the number of cells, corners, and
edges within the data, so it is important to maintain the integrity of these
mapping arrays such that they map to real indices.

The reindexing of the connectivity variables relies on the recalculated index
array of the associated domain.  For example, when reindexing the mapping from
cells to corners, the recalculated corners index array is required.  The
mapping values represent indices into the recalculated index array, so the
values are organized into set of indices for the GA routine \verb=NGA_Gather=
to query.  The \verb=NGA_Gather= routine gathers array elements from a global
array into a local array and in this case gathers the new values for the
mapping.  The gathered values then appropriately replace the old mapping
values.

\subsubsection{N-DIMENSIONAL PACK ROUTINE}
\label{section:alg_pack}

TODO -- Consider pseudo code?  \verb=GA_Scan_add= routine was used to perform
partial sums on all masks. That helps determine where to \verb=NGA_Put= the
subset data.

