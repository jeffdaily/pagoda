/**
 * Test the Array::get_mask() function.
 *
 * Every process verifies that the mask was correctly generated by performing
 * mask generation locally and comparing to the global result.
 */
#if HAVE_CONFIG_H
#   include "config.h"
#endif

#include <stdint.h>

#include <algorithm>
#include <cstdlib>
#include <functional>
#include <numeric>
#include <vector>

using std::accumulate;
using std::rand;
using std::srand;
using std::vector;

#include "Array.H"
#include "Bootstrap.H"
#include "DataType.H"
#include "Debug.H"
#include "Mask.H"
#include "Util.H"
#include "ValidMaskCondition.H"


int main(int argc, char **argv)
{
    Array *array = NULL;
    Mask *mask = NULL;
    vector<int64_t> shape;
    int64_t n = 0;
    vector<double> randomness;
    int retcode = 0;
    double mask_value = 0.0;
    int64_t global_result = 0;
    int64_t local_result = 0;
    double *array_data = NULL;

    pagoda::initialize(&argc,&argv);

    shape.push_back(10);
    shape.push_back(20);
    n = accumulate(shape.begin(), shape.end(), 1, std::multiplies<int64_t>());

    array = Array::create(DataType::DOUBLE, shape);

    /* fill the array with random numbers */
    randomness.reserve(n);
    srand(pagoda::me);
    for (int64_t i=0; i<n; ++i) {
        randomness.push_back(rand());
    }
    /* make sure all procs have the same randomness (via average) */
    pagoda::gop_sum(randomness);
    std::transform(randomness.begin(), randomness.end(), randomness.begin(),
            std::bind2nd(std::divides<double>(), pagoda::npe));
    /* process 0 initializes the global array */
    if (0 == pagoda::me) {
        array->put(&randomness[0]);
    }
    pagoda::barrier();

    /* first mask retrieved should be all 1's */
    mask = array->get_mask();
    retcode = (NULL == mask ? 1 : 0);
    pagoda::gop_sum(retcode);
    if (0 != retcode) {
        pagoda::println_zero("valid mask should have been returned");
        pagoda::finalize();
        return retcode;
    }
    retcode = (mask->get_count() == n ? 0 : 1);
    pagoda::gop_sum(retcode);
    if (0 != retcode) {
        pagoda::println_zero("all mask bits should have been set");
        pagoda::finalize();
        return retcode;
    }
    delete mask; // we're done with the first all-1's mask

    /* set a mask condition */
    mask_value = rand();
    pagoda::gop_sum(mask_value);
    mask_value /= pagoda::npe;
    array->set_validator(new ValidMaskCondition<double>("<",mask_value));

    /* this mask should *not* be all 1's */
    mask = array->get_mask();
    global_result = mask->get_count();
    array_data = (double*)array->get();
    for (int64_t i=0; i<n; ++i) {
        if (array_data[i] < mask_value) {
            ++local_result;
        }
    }
    delete mask;
    delete [] array_data;
    retcode = (local_result == global_result ? 0 : 1);
    pagoda::gop_sum(retcode);
    if (0 != retcode) {
        pagoda::println_zero("Array::get_mask() failed");
        pagoda::finalize();
        return retcode;
    }

    pagoda::finalize();
    return EXIT_SUCCESS;
}
